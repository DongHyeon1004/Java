# 변수

# 변수란?

**“변수란, 단 하나의 값을 저장할 수 있는 메모리 공간”**

프로그래밍 언어에서의 변수란, 값을 저장할 수 있는 메모리 상의 공간을 의미한다.

---

# 변수의 선언

```java
int age; // int : 변수타입, age : 변수이름
```

**변수 타입** : 변수에 저장될 값이 어떤 타입(type)인지 지정하는 것

**변수 이름** : 변수에 붙인 이름으로, 값을 저장할 수 있는 메모리 공간에 이름을 붙여주는 것

변수를 선언하면, 메모리의 빈 공간에 변수 타입에 맞는 크기의 저장 공간이 확보되고, 이 저장 공간은 변수 이름을 통해 사용할 수 있다.

# 변수의 초기화

**“변수의 초기화란, 변수를 사용하기 전에 처음으로 값을 저장하는 것”**

```java
int age = 25;  // 정수형 변수 age를 선언하고 25로 초기화
```

변수에 값을 저장할 때는 대입 연산자 **=**을 사용한다. 오른쪽 값을 왼쪽(변수)에 저장하라는 뜻이기에 대입 연산자의 왼쪽에는 반드시 변수가 와야 한다.

# 변수의 명명규칙

1. 대소문자가 구분되며 길이에 제한이 없다.
    - True와 true는 서로 다른 것으로 간주된다.
2. 예약어를 사용해서는 안 된다.
    - **예약어** : 프로그래밍 언어의 구문에 사용되는 단어
        
        ![Untitled](https://github.com/DongHyeon1004/Java/blob/main/Java/image/2-1.png)
        
3. 숫자로 시작해서는 안 된다.
    - top10은 허용하지만, 7up은 허용되지 않는다.
4. 특수 문자는 **_**와 **$**만을 허용한다.
    - $harp은 허용되지만, S#arp는 허용되지 않는다.

**권장하는 규칙**

1. 클래스 이름의 첫 글자는 항상 대문자로 한다.
    - 변수와 메서드의 이름의 첫 글자는 항상 소문자로 한다.
2. 여러 단어로 이루어진 이름은 단어의 첫 글자를 대문자로 한다.
    - lastIndexOf, StringBuffer
3. 상수의 이름은 모두 대문자로 한다. 여러 단어로 이루어진 경우 **_**로 구분한다.
    - PI, MAX_NUMBER

---

# 변수의 타입

![Untitled](https://github.com/DongHyeon1004/Java/blob/main/Java/image/2-2.png)

값의 종류는 크게 문자와 숫자로 나뉘고 숫자는 정수와 실수로 나뉜다.

**자료형** : 값의 종류에 따라 값이 저장될 공간의 크기와 저장 형식을 정의한 것

- **기본형** : 실제 값을 저장
    - 논리형(boolean), 문자형(char), 정수형(byte, short, int, long), 실수형(float, double)
- **참조형** : 어떤 값이 저장되어 있는 주소를 저장
    - 8개의 기본형을 제외한 나머지 타입
    - 참조형 변수 간의 연산은 불가능하다.
    - 참조형 변수를 선언할 때는 변수의 타입으로 클래스의 이름을 사용하므로 클래스의 이름이 참조 변수의 타입이 된다.
    
    ```java
    클래스이름 변수이름; // 변수의 타입이 기본형이 아닌 것들은 모두 참조변수이다.
    ```
    

# 기본형(primitive type)

- **논리형**
    - boolean(1 byte)
    - true / false 중 하나를 값으로 가지며, 조건식과 논리적 계산에 사용
    
    ```java
    boolean power = true; 
    boolean checked = False; // 에러. true / false만 가능.
    ```
    
- **문자형**
    - char(2 byte)
    - 문자를 저장하는데 사용, 변수에 하나의 문자만 저장, 내부적으로 정수(유니코드)로 저장하기 때문에 정수형, 실수형과 연산 가능
    
    ```java
    char ch1 = 'A'; // 문자 'A'를 ch1에 저장. A의 유니코드 65가 저장됨.
    short s = 65; // 똑같은 값이 저장됨.
    
    int code = (int)ch1; // ch1에 저장된 값을 int타입으로 변환하여 저장.
    
    System.out.println(ch1); // A 출력
    System.out.println(s); // 65 출력
    ```
    
    - **특수문자**
    
    ![Untitled](https://github.com/DongHyeon1004/Java/blob/main/Java/image/2-3.png)
    
    - **char 표현 형식**
    
    ![Untitled](https://github.com/DongHyeon1004/Java/blob/main/Java/image/2-4.png)
    
    - **문자 인코딩** : 문자를 코드로 변환하는 것
    - **문자 디코딩** : 코드를 문자로 변환하는 것
- **정수형**
    - byte(1 byte), short(2 byte), **int(4 byte)**, double(8 byte)
    - 정수를 저장하는데 사용, 주로 기본 자료형 int 사용. byte는 이진 데이터를 다룰 때 사용, short는 C언어와의 호환을 위해서 추가
    - **저장 가능한 값의 범위 : $-2^{n-1}$ ~ $2^{n-1}-1$ (n은 bit수)**
    - **표현 가능한 정수의 개수 : $2^n$개**
    - **정수형의 표현 형식**
        
        ![Untitled](https://github.com/DongHyeon1004/Java/blob/main/Java/image/2-5.png)
        
    - **오버플로우 :** 타입이 표현할 수 있는 값의 범위를 넘어서는 것
        
        ex) 4bits
        
             1 1 1 1 + 1 = **1** 0 0 0 0      저장할 수 있는 공간이 없어서 1은 버려짐.
        
             **1** 0 0 0 0 - 1 = 1 1 1 1       저장되지 않은 1이 있다고 가정하고 계산.
        
    - **최대값 + 1 → 최소값**
        
        **최소값 + 1 → 최대값**
        
    - **부호 있는 정수형 오버플로우 :** 부호 비트가 0 → 1, 1 → 0으로 바뀔 때 발생
        
        0 1 1 1 (7) → 1 0 0 0 (-8)
        
        1 1 1 1 (-1) → 0 0 0 0 (0)
        
- **실수형**
    - float(4 byte), **double(8 byte)**
    - 실수를 저장하는데 사용, 주로 기본 자료 double 사용
    - 정수형과 저장 형식이 달라 같은 크기라도 훨씬 큰 값 표현 가능, 오차가 발생할 수 있음.
    
    ![Untitled](https://github.com/DongHyeon1004/Java/blob/main/Java/image/2-6.png)
    
    ![Untitled](https://github.com/DongHyeon1004/Java/blob/main/Java/image/2-7.png)
    
    - E : 부호 있는 정수인 지수를 저장하는 부분
    - M : 실제 값인 가수를 저장하는 부분
    - 정밀도가 높을수록 오차의 범위가 줄어든다.
    - float 정밀도 : 7 자리, double 정밀도 : 15 자리
    - 연산 속도의 향상이나 메모리 절약을 위해선 float, 더 큰 값의 범위거나 더 높은 정밀도를 위해선 double을 선택해야 한다.
    - **부동소수점의 오차**
        
        2진수로 변환 시에 무한 소수가 되거나 유한 소수지만 가수를 저장할 수 있는 자리 수가 한정되어 있으므로 저장되지 못하고 버려지는 값들이 있으면 오차가 발생한다.
        
        **정규화** : 2진수로 변환된 실수를 저장할 때 [1.xxx](http://1.xxx) X $2^n$의 형태로 변환하는 과정.
        
        정규화된 2진 실수를 항상 1. 으로 시작하기 때문에 1. 을 제외한 23자리 2진수가 가수에 저장되고 나머지는 잘려나간다.
        
        지수는 기저법으로 저장되기 때문에 지수에 127을 더한 값이 2진수로 변환되어 저장된다.
        
    
    ---
    
    # 상수
    
    변수와 마찬가지로 값을 저장할 수 있는 공간이지만, 변수와 달리 **한 번 값을 저장하면 다른 값으로 변경할 수 없다.**
    
    ```java
    final int MAX_SPEED = 10; // final을 붙여주면 상수 선언, 상수 MAX_SPEED 선언 & 초기화
    ```
    
    상수는 반드시 선언과 동시에 초기화 해야 하며, 그 후 상수의 값을 변경을 허용하지 않는다.
    
    ```java
    final int MAX_SPEED; // 에러. 선언과 동시에 초기화 해야 함.
    final int MAX_VALUE = 100; // OK.
    MAX_VALUE = 200; // 에러. 상수의 값은 변경할 수 없음.
    ```
    
    상수의 이름은 모두 대문자로 하는 것이 암묵적인 관례, 단어 구분은 _로 한다.
    
    # 리터럴(literal)
    
    **그 자체로 값을 의미하는 것**
    
    상수를 한 번 값을 저장하면 변경할 수 없는 저장 공간으로 정의 했기 때문에 구분하기 위한 상수의 다른 이름
    
    ```java
    int year = 2023;
        변수   리터럴
    final int MAX_VALUE = 100;
                 상수     리터럴
    ```
    
    **상수가 필요한 이유**
    
    ```java
    final int WIDTH = 20;
    final int HEIGHT = 10;
    
    int triangleArea = (WIDTH * HEIGHT) / 2;
    int rectangleArea = WIDTH * HEIGHT;
    ```
    
    코드의 의미가 명확해지고, 다른 값으로 계산할 때도 여러 곳을 수정할 필요 없이 상수의 초기화만 다른 값으로 해주면 된다. 
    
    상수는 리터럴에 의미 있는 이름을 붙여서 코드의 이해와 수정을 쉽게 만든다.
    

### 리터럴의 타입과 접미사

변수의 타입은 저장될 값의 타입(리터럴의 타입)에 의해 결정되므로, 리터럴에 타입이 없다면 변수의 타입도 필요없을 것이다.

- 정수형 접미사 : **L**
    - 정수형의 경우, long타입의 리터럴에 접미사 l 또는 L 을 붙이고, 접미사가 없다면 int타입의 리터럴이다.
    - byte와 short타입의 리터럴은 별도로 존재하지 않고, int타입의 리터럴을 사용해서 값을 저장한다.
    - 8진수의 경우 리터럴 앞에 접두사 0, 16진수의 경우 리터럴 앞에 접두사 0x / 0X 을 붙인다.
    
    ```java
    int binNum = 0b10; // 2진수 10
    int octNum = 010; // 8진수 10
    int hexNum = 0x10; // 16진수 10
    ```
    
- 실수형 접미사 : **f**, d
    - float타입의 리터럴에 f / F, double타입의 리터럴에 d / D를 붙인다.
    - 실수형에서는 **double이 기본 자료형이기 때문에 접미사 d는 생략 가능**
    - 실수형 리터럴에 접미사가 없으면 double타입 리터럴
        
        ```java
        float pi = 3.14; // 에러. float타입 변수에 double타입 리터럴은 저장 불가
        float pi = 3.14f; // OK.
        double rate = 1.618; // OK. 접미사 d 생략 가능
        ```
        
- 나머지 자료형들은 접미사 x
- 리터럴에 소수점이나 10의 제곱을 나타내는 기호 E / e, 그리고 접시마 f / F / d / D를 포함하고 있으면 실수형 리터럴로 간주.

### 타입의 불일치

리터럴의 타입은 저장될 변수의 타입과 일치하는 것이 보통이지만, 타입이 달라도 **저장 범위가 넒은 타입에 좁은 타입의 값을 저장하는 것은 허용**

```java
int i = 'A' // OK. 문자는 유니코드의 값으로 저장. 
long l = 123; // OK. int보다 long의 범위가 넓음.
double d = 3.14f; // OK. float보다 double의 범위가 넓음.
```

리터럴의 값이 변수의 타입의 범위를 넘어서거나, 리터럴의 타입이 변수의 타입보다 저장 범위가 넓으면 컴파일 에러가 발생한다.

```java
int i = 0x123456789; // 에러. int 범위를 넘는 값.
float f = 3.14; // 에러. float보다 double의 범위가 넓음.
```

byte와 short타입의 리터럴은 따로 존재하지 않아서 int타입의 리터럴 사용하지만, 각각의 타입의 변수가 저장할 수 있는 범위에 속해야 한다.

```java
byte b = 65; // OK. byte타입에 저장 가능한 범위의 int 리터럴.
short s = 0x1234; // OK. short타입에 저장 가능한 범위의 int 리터럴.
```

### 문자 리터럴과 문자열 리터럴

**문자 리터럴** : ‘A’와 같이 작은 따옴표로 문자 하나를 감싼 것

- 문자 리터럴은 반드시 ‘ ‘안에 하나의 문자가 존재해야 한다.

**문자열 리터럴** : “Java”와 같이 큰 따옴표로 두 문자 이상을 감싼 것

- 문자열 리터럴을 저장하기 위해서는 String타입을 사용해야 한다.
- 문자열 리터럴은 “ “안에 아무런 문자도 넣지 않는 것을 허용하고 이를 빈 문자열이라고 한다.

```java
String str = ""; // OK. 빈 문자열.
char ch1 = ''; // 에러. 반드시 하나의 문자가 필요.
char ch2 = ' '; // OK. 공백 문자로 ch2를 초기화.

String name = new String("Java"); /* String은 클래스이므로 객체를 생성하는 연산자 new를
																	사용해야 하지만 위와 같은 표현도 허용 */

// 덧셈 연잔자를 이용해 문자열 결합 가능
String name = "Ja" + "va"; // name은 "Java"
String str = name + 8.0; // str은 "Java8.0"
```

덧셈 연산자(+)는 모두 숫자일 때는 두 수를 더하지만, **어느 한 쪽이 String이면 나머지 한 쪽을 먼저 String으로 변환한 다음 두 String을 결합한다**. 어떤 타입의 변수도 문자열과 덧셈 연산을 수행하면 그 결과는 문자열이 된다.

```java
문자열 + **any type** -> 문자열 + **문자열** -> 문자열
**any type** + 문자열 -> **문자열** + 문자열 -> 문자열
```

### **문자열 결합의 예**

```java
**7** + " " -> **"7"** + " " -> "7 "
" " + **7** -> " " + **"7"** -> " 7"
**7** + "7" -> **"7"** + "7" -> "77"

**7 + 7** + "" -> **14** + "" -> **"14"** + "" -> "14"
"" + **7** + 7 -> "" + **"7"** + 7 -> "7" + **7** -> "7" + **"7"** -> "77"

**true** + "" -> **"true"** + "" -> "true"
```

덧셈 연산자는 왼쪽 → 오른쪽 방향으로 연산을 수행하기 때문에 결합 순서에 따라 결과가 달라진다.

---

# 형식화된 출력 - printf()

println()은 변수의 값을 그대로 출력하므로, 값을 변환하지 않고는 다른 형식으로 출력할 수 없다. printf()는 **같은 값을 다른 형식으로 출력하고 싶을 때 사용**할 수 있다. printf()는 **지시자를 통해 변수의 값을 여러가지 형식으로 변환하여 출력하는 기능**을 가지고 있다. 지시자는 값을 어떻게 출력할 것 인지를 지정해주는 역할을 하며, 변수의 값을 지정된 형식으로 변환해서 지시자대신 넣는다.

```java
int age = 14;

System.out.printf("age : %d", age); // 화면에 age : 14 가 출력된다.
```

printf()는 출력 후 줄 바꿈을 하지 않기 때문에 줄 바꿈을 하려면 지시자 **%n**을 사용해야 한다.

```java
System.out.printf("age : %d", age); // 출력 후 줄 바꿈을 하지 않음.
System.out.printf("age : %d%n", age); // 출력 후 줄 바꿈을 함.
```

### **자주 사용되는 지시자**

- %b : 불리언(**b**oolean)형식으로 출력
- %d : 10진(**d**ecimal) 정수 형식으로 출력
- %o : 8진(**o**ctal) 정수 형식으로 출력
- %x, %X : 16진(he**x**a-decimal) 정수 형식으로 출력
- %f : 부동 소수점(**f**loating-point) 형식으로 출력
- %e, %E : 지수(**e**xponent) 표현식 형식으로 출력
- %c : 문자(**c**haracter)로 출력
- %s : 문자열(**s**tring)로 출력

```java
int finger = 10;
long hex = 0xFFFF_FFFF_FFFF_FFFFL:

System.out.printf("finger = [%5d] %n", finger); // finger = [   10] 오른쪽 정렬
System.out.printf("finger = [%-5d] %n", finger); // finger = [10   ] 왼쪽 정렬
System.out.printf("finger = [%05d] %n", finger); // finger = [00010] 나머지를 0으로 채움

System.out.printf("hex = %x%n", hex); // hex = ffffffffffffffff
System.out.printf("hex = %**#x**%n", hex); // hex = 0xffffffffffffffff
System.out.printf("hex = %**#X**%n", hex); // hex = 0XFFFFFFFFFFFFFFFF
```

10진수를 2진수로 출력해주는 지시자는 없기 때문에 정수를 2진 문자열로 변환해주는 

**Interger.toBinaryString(int i)**를 사용해야 한다.

```java
int binNum = 0b10;

System.out.printf("binNum = %s%n", Interger.toBinaryString(binNum)); // binNum = 10
```

char타입의 경우 **형변환을 꼭 해야만** %d로 출력할 수 있다.

```java
char = 'A';

System.out.printf("c = %c, %d %n", c, (int)c); // c = A, 97
```

%f는 기본적으로 소수점 아래 6번째 자리까지만 출력하기 때문에 소수점 아래 7번째 자리에서 반올림한다. 아래의 방법을 사용해 전체 자리 수와 소수점 아래의 자리수를 지정할 수 있다.

**%전체자리.소수점아래자리f**

```java
double d = 1.23456789;
String url = "www.codechobo.com";

System.out.printf("d = %14.10f%n", d); /* d =   1.2345678900 정수의 빈자리는 공백으로,
                                                           소수점 아래 빈자리는 0으로 채움.*/

System.out.printf("[%s]%n); // [www.codechobo.com] 문자열의 길이만큼.
System.out.printf("[%20s]%n); // [   www.codechobo.com] 최소 20글자 출력공간, 오른쪽 정렬.
System.out.printf("[%-20s]%n); // [www.codechobo.com   ] 최소 20글자 출력공간, 왼쪽 정렬.
System.out.printf("[%.8s]%n); // [www.code] 왼쪽에서 8글자만 출력, 소수점도 한 자리를 차지함.
```

# 화면에서 입력받기 - Scanner

Scanner클래스를 이용하면 화면으로부터 입력을 받을 수 있다.

```java
import java.util.*; //Scanner 클래스를 사용하기 위해 추가 

class ScannerEx {
	public static void main(String[] args) {
			Scanner scanner = new Scanner(System.in); // Scanner 클래스의 객체 생성

			System.out.print("두자리 정수를 하나 입력하세요. : ");
			String input = scanner.nextLine(); // 입력받은 내용을 input에 저장
			int sum = Integer.parseInt(input); // 입력받은 내용을 int타입의 값으로 변환

			System.out.println("입력 내용 :"+input);
			System.out.printf("num = %d%n", num);
	}
}
```

Scanner 클래스에는 nextInt() / nextFloat()같이 변환 없이 숫자로 바로 입력 받을 수 있는 메서드들이 있지만, 화면에서 연속적으로 값을 입력 받아서 사용하기에 까다롭기 때문에, nextLine()으로 입력 받아서 적절히 변환하는 것이 더 좋다.  

---

# 진법

### **10진법과 2진법**

컴퓨터는 2진수만 이해하기 때문에 2진수로 바뀌어 저장된다.

```java
int age = 25; // 11001로 저장, 32자리로 표현해야 하지만 0은 생략.
```

### **비트(bit)와 바이트(byte)**

**비트** : 한자리의 2진수, 컴퓨터가 값을 저장할 수 있는 최소 단위

**바이트** : 8비트의 데이터의 기본 단위

**워드** : CPU가 한 번에 처리할 수 있는 데이터의 크기

    1워드는 CPU의 성능에 따라 달라진다. 64비트라면 1워드는 64비트다. 하프워드 = 32비트

### **n비트로 표현할 수 있는 10진수
값의 개수 : 2<sup>n</sup>

**값의 범위 : 0 ~ 2<sup>n-1</sup>**

**이진수 → 십진수**

ex) 

1   0   1   0   0

16  8  4   2   1

16+4=20
10100<sub>(2)</sub> → 20<sub>(10)</sub>


1     1     0     1     1     0   

32  16    8     4     2     1

32+16+4+2=54
110110<sub>(2)</sub> → 54<sub>(10)</sub>


1   .   1

1      0.5

1+0.5=1.5
1.1<sub>(2)</sub> → 1.5<sub>(10)</sub>

**십진수 → 이진수**

십진수를 2<sup>n</sup>의 덧셈으로 나눈다.

ex) 

85<sub>(10)</sub> = 2<sup>6</sup> + 2<sup>4</sup> + 2<sup>2</sup> + 2<sup>0</sup>

85<sub>(10)</sub> = 1010101<sub>(2)</sub>

37<sub>(10)</sub> = 2<sup>5</sup> + 2<sup>2</sup> +2<sup>0</sup>

37<sub>(10)</sub>  = 100101<sub>(2)</sub>

**이진수의 음수 표현**

1의 보수 - 1 → 0, 0 → 1

2의 보수 - 1의 보수 + 1

ex) 10101의 음수 표현 

10101<sub>(2)</sub> → 01010<sub>(2)</sub> → 01011<sub>(2)</sub>

             1의 보수     2의 보수

**십육진수**

수학적 표기 : 아래첨자 <sub>(16)</sub> 사용    ex) D5<sub>(2)</sub>

코드상 표기 : 0x를 앞에 사용    ex) 0xD5

0-9, A-F(10-15)

**이진수 → 십육진수**

4bits씩 끊어서 대응하는 십육진수로 바꿔줌.

ex)

11010101<sub>(2)</sub> → D5<sub>(16)</sub>

1101<sub>(2)</sub> → 13<sub>(10)</sub> → D<sub>(16)</sub>

0101<sub>(2)</sub> → 5<sub>(10)</sub> → 5<sub>(16)</sub>

**십육진수 → 이진수**

십육진수의 한글자를 4bits의 이진수로 바꿔줌.

ex)

2D<sub>(16)</sub> → 00101101<sub>(2)</sub>

2<sub>(16)</sub> → 2<sub>(10)</sub> → 0010<sub>(2)</sub>

D<sub>(16)</sub> → 13<sub>(10)</sub> → 1101<sub>(2)</sub>

# 실수의 진법변환

**10진 소수점수 → 2진 소수점수**

소수 부분이 0이 될 때까지 2를 곱해준 후, 정수 부분을 위에서 아래로 적고 앞에 0.을 붙인다.

ex)

0.625 x 2 = 1.**25**

**0.25** x 2 = 0.**5**

**0.5** x 2 = 1.0

0.625 → 0.101<sub>(2)</sub>

**2진 소수점수 → 10진 소수점수**

정수의 변환처럼 각 자리에 맞는 수를 곱해서 더해주면 됨.

---

# 형변환(casting)

**형변환이란, 변수 또는 상수의 타입을 다른 타입으로 변환하는 것**

연산을 수행하기 전에 타입의 일치가 필요한 경우에 사용한다.

### **형변환 방법**

형변환을 하고자 하는 변수나 리터럴의 앞에 변환하고자 하는 타입을 괄호와 함께 붙인다.

                                              **(타입)변수 / 리터럴**

```java
double d = 85.4;
int score = (int)d; // 85가 저장됨.

// 변수 d의 값은 형변환 후에도 변화가 없음.
```

boolean을 제외한 나머지 기본형 타입들은 서로 형변환이 가능하다.

기본형과 참조형간의 형변환은 불가능하다.

### **정수형 간의 형변환**

큰 타입 → 작은 타입 변환은 크기의 차이만큼 잘려나가 값 손실이 발생할 수 있다.

ex) int → byte 

0….100101100 → 00101100

     (300)              (44)           값 손실 발생

작은 타입 → 큰 타입 변환의 경우 저장 공간의 부족으로 잘려나가는 일이 없으므로 값 손실이 발생하지 않는다. 나머지 빈 공간은 0 / 1로 채워진다.

원래의 값을 채우고 남은 빈 공간은 0으로 채우는게 보통이지만, 변환하려는 값이 음수인 경우에는 형변환 후에도 부호를 유지할 수 있도록 빈 공간을 1로 채운다.

### 실수형 간의 형변환

작은 타입 → 큰 타입 변환의 경우 정수처럼 빈 공간은 0으로 채운다.

float → double 변환 경우 지수는 127을 뺀 후 1023을 더해서 변환하고, 가수는 float의 가수 23자리를 채우고 남은 자리를 0으로 채운다.

ex) float → double

0 10000010 111….1 → 0 10000000010 111…1000000….0

큰 타입 → 작은 타입

double → float 변환 경우 지수는 1023을 뺀 후 127을 더해서 변환하고, 가수는 52자리 중 23자리만 저장되고 나머지는 버려진다.

24번째 자리에서 반올림이 발생할 수 있다.

ex)

0 10000000010 111….100…..0 → 0 10000010 111…..1~~00…0~~

### 정수형 → 실수형 변환

정수를 2진수로 변환한 후 정규화를 거쳐 실수의 저장형식으로 저장한다.

ex) 10진수 7 변환

0 00….0111 → 1.11 x $2^2$ → 0 10000001 11 00…0

실수형의 정밀도의 제한으로 인한 오차가 발생할 수 있다.

int는 최대 10자리의 정밀도를 요구하지만, float의 정밀도는 7자리이므로 정밀도 차이로 인한 오차가 발생할 수 있다. 8자리 이상의 10진수를 실수형으로 변환할 때는 double로 형변환해야 오차가 발생하지 않는다.

### 실수형 → 정수형 변환

실수형을 정수형으로 변환하면, 정수형의 표현 형식으로는 소수점 이하의 값은 표현할 수 없기 때문에 실수형의 소수점 이하 값은 버려진다.

ex)

0 10000010 001000111111001101011110 (9.1234567)

→ 0 00…01001 (9)

실수형을 정수형으로 형변환할 때는 반올림이 발생하지 않는다.

ex)

1.666 → (int) → 1

실수의 소수점을 버리고 남은 정수가 정수형의 저장범위를 넘는 경우에 정수의 오버플로우가 발생한 결과를 얻는다.

### 자동 형변환

서로 다른 타입 간의 대입이나 연산의 경우 형변환으로 타입을 일치시키는 것이 원칙이지만 편의상 형변환을 생략할 수 있는데, 이 때 컴파일러가 생략된 형변환을 자동적으로 추가한다.

```java
float f =1234; // 형변환 생략. float f = (float)1234; 와 같은 문장.
```

변수가 저장할 수 있는 값의 범위보다 더 큰 값을 저장하려는 경우 형변환 생략 시 오류가 발생한다.

```java
byte b = 1000; // 에러. byte의 범위를 넘는 값을 저장.
```

하지만 명시적으로 형변환을 해주는 경우, 프로그래머의 실수가 아닌 의도적인 것으로 간주하고 컴파일러는 에러를 발생시키지 않는다.

```java
char ch = (char)1000; // 명시적 형변환으로 에러가 발생하지 않음.
```

서로 다른 타입의 연산에서는 타입을 일치시켜줘야 하기 때문에 연산과정에서 형변환이 자동적으로 이루어진다. **연산과정에서 자동적으로 발생하는 형변환을 산술 변환**이라고 한다.

```java
int i = 3;
double d = 1.0 + i; // double d = 1.0 + (double)i; 자동 형변환이 이루어진다.
```

### 자동 형변환의 규칙

컴파일러는 **기존의 값을 최대한 보존할 수 있는 타입으로 자동 형변환한다.** 표현 범위가 좁은 타입에서 넓은 타입으로 형변환 하는 경우에는 값 손실이 없기 때문이다.

- **byte → short, char → int → long → float → double**

오른쪽에서 왼쪽으로의 형변환의 경우 **반드시 형변환 연산자를 써줘야 한다.**

float / double이 int / long보다 훨씬 더 큰 표현 범위를 갖기 때문에 오른쪽에 위치한다.

1. **boolean을 제외한 나머지 7개의 기본형은 서로 형변환이 가능하다.**
2. **기본형과 참조형은 서로 형변환할 수 없다.**
3. **서로 다른 타입의 변수간의 연산은 형변환을 하는 것이 원칙이지만, 값의 범위가 작은 타입에서 큰 타입으로의 형변환은 생략할 수 있다.**
